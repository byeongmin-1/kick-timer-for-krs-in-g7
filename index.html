import React, { useEffect, useMemo, useRef, useState } from "react";

// Named Multi‑Timer (Countdown) — up to 10 years
// Features
// • Create multiple named timers
// • Count down in hours, minutes, seconds (also shows days if large)
// • Start / Pause / Reset / Delete each timer
// • Progress bar + status badges
// • LocalStorage persistence
// • 10‑year hard cap for any single timer
//
// Drop this component into a React app. If you open this canvas preview,
// it should render with Tailwind (the preview includes Tailwind automatically).

const MAX_YEARS = 10;
const MS_IN_SECOND = 1000;
const MS_IN_MINUTE = 60 * MS_IN_SECOND;
const MS_IN_HOUR = 60 * MS_IN_MINUTE;
const MS_IN_DAY = 24 * MS_IN_HOUR;
// 10 * 365.25 days for a practical cap that accounts for leap years on average
const MAX_DURATION_MS = Math.floor(MAX_YEARS * 365.25 * MS_IN_DAY);

function clampDuration(ms) {
  return Math.max(0, Math.min(ms, MAX_DURATION_MS));
}

function formatHMS(ms) {
  // Returns {days, hh, mm, ss} and a display string like "2d 05:04:03"
  const days = Math.floor(ms / MS_IN_DAY);
  ms %= MS_IN_DAY;
  const hours = Math.floor(ms / MS_IN_HOUR);
  ms %= MS_IN_HOUR;
  const minutes = Math.floor(ms / MS_IN_MINUTE);
  ms %= MS_IN_MINUTE;
  const seconds = Math.floor(ms / MS_IN_SECOND);
  const hh = String(hours).padStart(2, "0");
  const mm = String(minutes).padStart(2, "0");
  const ss = String(seconds).padStart(2, "0");
  return {
    days,
    hours,
    minutes,
    seconds,
    text: (days > 0 ? `${days}d ` : "") + `${hh}:${mm}:${ss}`,
  };
}

function prettyNumber(n) {
  return new Intl.NumberFormat().format(n);
}

function loadTimers() {
  try {
    const raw = localStorage.getItem("named-multi-timers");
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    // Filter out any malformed timers
    return parsed.filter((t) =>
      t && typeof t.id === "string" && typeof t.name === "string" && typeof t.durationMs === "number"
    );
  } catch {
    return [];
  }
}

function saveTimers(timers) {
  try {
    localStorage.setItem("named-multi-timers", JSON.stringify(timers));
  } catch {
    // ignore
  }
}

function useNow(runningAny) {
  const [now, setNow] = useState(Date.now());
  useEffect(() => {
    // Use a modest interval to keep CPU low while staying responsive
    const interval = setInterval(() => setNow(Date.now()), runningAny ? 250 : 1000);
    return () => clearInterval(interval);
  }, [runningAny]);
  return now;
}

export default function App() {
  const [timers, setTimers] = useState(() => {
    const loaded = loadTimers();
    // Ensure remainingMs & lastTick exist
    return loaded.map((t) => ({
      ...t,
      remainingMs: typeof t.remainingMs === "number" ? t.remainingMs : t.durationMs,
      running: Boolean(t.running),
      lastTick: typeof t.lastTick === "number" ? t.lastTick : Date.now(),
    }));
  });

  const [name, setName] = useState("");
  const [hours, setHours] = useState("");
  const [minutes, setMinutes] = useState("");
  const [seconds, setSeconds] = useState("");
  const nameInputRef = useRef(null);

  const runningAny = timers.some((t) => t.running);
  const now = useNow(runningAny);

  // Tick logic: compute new remaining based on real elapsed time (resilient to tab sleeps)
  useEffect(() => {
    setTimers((prev) => {
      const updated = prev.map((t) => {
        if (!t.running) return t;
        const elapsed = now - t.lastTick;
        if (elapsed <= 0) return t;
        const newRemaining = Math.max(0, t.remainingMs - elapsed);
        return {
          ...t,
          remainingMs: newRemaining,
          running: newRemaining > 0 && t.running,
          lastTick: now,
        };
      });
      return updated;
    });
  }, [now]);

  // Persist
  useEffect(() => {
    saveTimers(timers);
  }, [timers]);

  const totalRunning = timers.filter((t) => t.running).length;

  function computeDurationMs(h, m, s) {
    const H = Math.max(0, Number(h || 0));
    const M = Math.max(0, Number(m || 0));
    const S = Math.max(0, Number(s || 0));
    let ms = H * MS_IN_HOUR + M * MS_IN_MINUTE + S * MS_IN_SECOND;
    ms = clampDuration(ms);
    return ms;
  }

  function addTimer(e) {
    e?.preventDefault();
    const durationMs = computeDurationMs(hours, minutes, seconds);
    if (!name.trim()) {
      alert("Please enter a name for the timer.");
      nameInputRef.current?.focus();
      return;
    }
    if (durationMs <= 0) {
      alert("Please set a duration greater than 0.");
      return;
    }
    const id = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);
    const newTimer = {
      id,
      name: name.trim(),
      durationMs,
      remainingMs: durationMs,
      running: false,
      lastTick: Date.now(),
    };
    setTimers((prev) => [newTimer, ...prev]);
    setName("");
    setHours("");
    setMinutes("");
    setSeconds("");
    nameInputRef.current?.focus();
  }

  function startTimer(id) {
    setTimers((prev) =>
      prev.map((t) => (t.id === id ? { ...t, running: t.remainingMs > 0, lastTick: Date.now() } : t))
    );
  }
  function pauseTimer(id) {
    setTimers((prev) => prev.map((t) => (t.id === id ? { ...t, running: false } : t)));
  }
  function resetTimer(id) {
    setTimers((prev) =>
      prev.map((t) => (t.id === id ? { ...t, remainingMs: t.durationMs, running: false } : t))
    );
  }
  function deleteTimer(id) {
    setTimers((prev) => prev.filter((t) => t.id !== id));
  }

  function editName(id, newName) {
    setTimers((prev) => prev.map((t) => (t.id === id ? { ...t, name: newName } : t)));
  }

  const totalCount = timers.length;

  return (
    <div className="min-h-screen w-full bg-gray-50 text-gray-900">
      <div className="mx-auto max-w-5xl px-4 py-8">
        <header className="mb-8 flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">Named Multi‑Timer</h1>
            <p className="text-sm text-gray-600">
              Create and manage multiple countdowns. Each timer is capped at {MAX_YEARS} years.
            </p>
          </div>
          <div className="rounded-full bg-white px-4 py-2 shadow">
            <span className="text-sm">Running: </span>
            <span className="font-semibold">{totalRunning}</span>
            <span className="text-sm"> / {totalCount}</span>
          </div>
        </header>

        {/* New Timer Form */}
        <form
          onSubmit={addTimer}
          className="mb-6 grid gap-3 rounded-2xl bg-white p-4 shadow lg:grid-cols-12"
        >
          <div className="lg:col-span-4">
            <label className="mb-1 block text-sm font-medium tracking-tight">Timer Name</label>
            <input
              ref={nameInputRef}
              className="w-full rounded-xl border border-gray-300 bg-white px-3 py-2 outline-none ring-0 focus:border-gray-400"
              placeholder="e.g., Project Deadline, Boiled Eggs, Workout Rest"
              value={name}
              onChange={(e) => setName(e.target.value)}
              maxLength={120}
              required
            />
          </div>

          <div className="lg:col-span-6 grid grid-cols-3 gap-3">
            <div>
              <label className="mb-1 block text-sm font-medium">Hours</label>
              <input
                type="number"
                min={0}
                inputMode="numeric"
                className="w-full rounded-xl border border-gray-300 bg-white px-3 py-2"
                placeholder="0"
                value={hours}
                onChange={(e) => setHours(e.target.value.replace(/[^0-9]/g, ""))}
              />
            </div>
            <div>
              <label className="mb-1 block text-sm font-medium">Minutes</label>
              <input
                type="number"
                min={0}
                max={59}
                inputMode="numeric"
                className="w-full rounded-xl border border-gray-300 bg-white px-3 py-2"
                placeholder="0"
                value={minutes}
                onChange={(e) => {
                  const v = e.target.value.replace(/[^0-9]/g, "");
                  setMinutes(v.slice(0, 2));
                }}
              />
            </div>
            <div>
              <label className="mb-1 block text-sm font-medium">Seconds</label>
              <input
                type="number"
                min={0}
                max={59}
                inputMode="numeric"
                className="w-full rounded-xl border border-gray-300 bg-white px-3 py-2"
                placeholder="0"
                value={seconds}
                onChange={(e) => {
                  const v = e.target.value.replace(/[^0-9]/g, "");
                  setSeconds(v.slice(0, 2));
                }}
              />
            </div>
          </div>

          <div className="lg:col-span-2 flex items-end justify-end">
            <button
              type="submit"
              className="w-full rounded-2xl bg-black px-4 py-2 font-semibold text-white shadow hover:opacity-90"
            >
              Add Timer
            </button>
          </div>

          <div className="lg:col-span-12 text-xs text-gray-600">
            <em>
              Tip: You can enter very large hour values (e.g., {prettyNumber(24 * 365 * MAX_YEARS)}) as long as
              the total duration does not exceed {MAX_YEARS} years (~{prettyNumber(Math.floor(MAX_DURATION_MS / MS_IN_DAY))} days).
            </em>
          </div>
        </form>

        {/* Timers List */}
        <section className="space-y-3">
          {timers.length === 0 && (
            <div className="rounded-2xl border border-dashed border-gray-300 bg-white p-6 text-center text-gray-600">
              No timers yet. Create one above to get started.
            </div>
          )}

          {timers.map((t) => {
            const pct = 100 - Math.floor((t.remainingMs / t.durationMs) * 100);
            const fmt = formatHMS(t.remainingMs);
            const totalHoursRemaining = Math.floor(t.remainingMs / MS_IN_HOUR);
            const finished = t.remainingMs === 0;

            return (
              <div
                key={t.id}
                className="grid gap-4 rounded-2xl bg-white p-4 shadow lg:grid-cols-12 lg:items-center"
              >
                <div className="lg:col-span-3">
                  <input
                    value={t.name}
                    onChange={(e) => editName(t.id, e.target.value)}
                    className="w-full rounded-xl border border-transparent px-2 py-1 text-lg font-semibold outline-none focus:border-gray-300"
                  />
                  <div className="mt-1 text-xs text-gray-500">ID: {t.id.slice(0, 8)}</div>
                </div>

                <div className="lg:col-span-5">
                  <div className="flex items-baseline gap-2">
                    <div className={`text-2xl font-mono ${finished ? "line-through text-gray-400" : ""}`}>
                      {fmt.text}
                    </div>
                    {fmt.days > 0 && (
                      <div className="text-xs text-gray-500">({fmt.days}d total)</div>
                    )}
                    <div className="ml-auto rounded-full bg-gray-100 px-2 py-0.5 text-xs">
                      {prettyNumber(totalHoursRemaining)} h left
                    </div>
                  </div>
                  <div className="mt-2 h-2 w-full rounded-full bg-gray-100">
                    <div
                      className={`h-2 rounded-full ${finished ? "bg-gray-300" : "bg-black"}`}
                      style={{ width: `${Math.min(100, Math.max(0, pct))}%` }}
                    />
                  </div>
                </div>

                <div className="lg:col-span-4 flex flex-wrap items-center gap-2">
                  {!finished && !t.running && (
                    <button
                      onClick={() => startTimer(t.id)}
                      className="rounded-xl bg-black px-3 py-2 text-sm font-semibold text-white shadow hover:opacity-90"
                    >
                      Start
                    </button>
                  )}
                  {!finished && t.running && (
                    <button
                      onClick={() => pauseTimer(t.id)}
                      className="rounded-xl bg-white px-3 py-2 text-sm font-semibold shadow hover:bg-gray-50"
                    >
                      Pause
                    </button>
                  )}
                  <button
                    onClick={() => resetTimer(t.id)}
                    className="rounded-xl bg-white px-3 py-2 text-sm font-semibold shadow hover:bg-gray-50"
                  >
                    Reset
                  </button>
                  <button
                    onClick={() => deleteTimer(t.id)}
                    className="rounded-xl bg-white px-3 py-2 text-sm font-semibold text-red-600 shadow hover:bg-gray-50"
                  >
                    Delete
                  </button>

                  <span
                    className={`ml-auto rounded-full px-2 py-1 text-xs font-semibold ${
                      finished
                        ? "bg-gray-100 text-gray-600"
                        : t.running
                        ? "bg-green-100 text-green-700"
                        : "bg-yellow-100 text-yellow-700"
                    }`}
                  >
                    {finished ? "Finished" : t.running ? "Running" : "Paused"}
                  </span>
                </div>
              </div>
            );
          })}
        </section>

        {/* Footer */}
        <footer className="mt-10 text-center text-xs text-gray-500">
          <p>
            Built with React + Tailwind. Data is saved to your browser. Max duration per timer: {MAX_YEARS} years.
          </p>
        </footer>
      </div>
    </div>
  );
}
